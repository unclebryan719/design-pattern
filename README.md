#### 设计模式七大原则

##### 单一职责原则

1. 一个类或者方法应该只负责一项职责

##### 接口隔离原则 Interface Segregation Principle

1. 客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小接口上

##### 依赖倒转原则 Dependence Inversion Principle

1. 概念
   1. 高层模块不应该依赖低层模块，二者都应该依赖其抽象
   2. 抽象不应该依赖细节，细节应该依赖抽象
   3. 依赖倒转的中心思想是面向接口编程
   4. 接口和抽象类的目的在于制定好规范
2. 依赖关系传递的三种方式
   1. 接口传递
   2. 构造方法传递
   3. setter方式传递
3. 注意事项
   1. 低层模块尽量都要有抽象类或者接口
   2. 变量的声明类型尽量是抽象类或者接口

##### 里氏替换原则 Liskov Substitution Principle

1. 继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖来解决问题

##### 开闭原则 OCP （Open Closed Principle）

1. **对扩展开放（对提供方），对修改关闭（对使用方）**。用抽象构建框架，用实现扩展细节

##### 迪米特法则 Demeter Principle

1. 迪米特法则又叫最少知道原则，即**一个类对自己依赖的类知道的越少越好**。对外除了提供public方法，不对外泄漏任何信息
2. 直接朋友：成员变量，方法参数，方法返回值中的类为直接朋友，而出现在局部变量中的类不是直接的朋友

##### 合成复用原则  Composite Reuse Principle

1. 尽量使用合成、聚合的方式，而不是使用继承

![image-20210523214447341](src/main/resources/image/typora-user-images/image-20210523214447341.png)



#### UML图

##### 概念

1. 用于描述系统中的类（对象）本身的组成和类（对象）之间的各种静态关系
2. 类之间的关系：依赖、泛化（继承）、实现、关联、聚合和组合。

##### 分类

1. 用例图（use case）
2. 静态结构图：**类图**、对象图、包图、组件图、部署图
3. 动态行为图：交互图（时序图与协作图）、状态图、活动图

##### 类之间的关系

1. 依赖关系 Dependence：A类中使用到B类，可以说A类依赖B类

   1. 类中用到了对方
   2. 类的成员属性
   3. 方法的返回类型
   4. 方法接收的参数类型

2. 泛化关系实际上就是继承关系（Generalization）

3. 实现关系 Implementation

4. 关联关系 Association 

   1. 类与类之间的联系，单向和双向的1对多，或者1对1

5. 聚合关系 Aggregation

   ![image-20210523222040292](src/main/resources/image/typora-user-images/image-20210523222040292.png)

6. 组合关系 Composition 整体和局部不可分开
   1. ![image-20210523222313658](src/main/resources/image/typora-user-images/image-20210523222313658.png)

![image-20210523222419016](src/main/resources/image/typora-user-images/image-20210523222419016.png)

#### 设计模式

设计模式分为三种类型，共23种

1. **创建型：**单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式
2. **结构型：**适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式
3. **行为型：**模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责链模式（责任链模式）

##### 单例模式

###### 概念

对某个类只能存在一个对象实例，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能

###### 实现单例的八种方式

1. <font color=red>饿汉式（静态常量）</font>
   1. 优点：写法简单，在类装载的时候就完成了实例化，避免线程同步问题
   2. 缺点：没有达到Lazy loading的效果，如果从始至终未使用过这个实例，可能会造成内存的浪费
2. <font color=red>饿汉式（静态代码块）</font>，与上面的方式的优缺点类似
3. 懒汉式（线程不安全），不推荐使用
4. 懒汉式（线程安全，同步方法），虽然解决了线程安全，但是synchronize导致效率低下，不推荐使用
5. 懒汉式（线程不安全，同步代码块），不推荐使用
6. <font color=red>双重检查，推荐使用</font>，解决了懒加载和线程安全的问题
7. <font color=red>静态内部类，推荐使用</font>，当外部类装载的时候静态内部类不会被装载，当调用静态内部类的静态变量的时候，静态内部类才会被装载，同时类的装载时线程安全的
8. <font color=red>枚举，推荐使用</font>，可以避免多线程同步问题，还能防止反序列化重新创建新的对象。

###### 单例模式使用场景

1. JDK中的Runtime类，使用的是饿汉式创建的
2. 需要频繁创建和销毁的对象
3. 创建对象时耗时过多或者耗费资源过多（即：重量级对象），但又经常用到的对象
4. 工具类对象、频繁访问数据库或者文件的对象（比如数据源、session工厂等）

###### 注意事项

1. 当想实例化一个单例类的时候，必须记住使用相应的获取对象的方法，而不是使用new

##### 简单工厂模式

###### 概念

简单工厂模式是由一个工厂对象决定创建出哪一类产品类的实例；简单工厂模式：定义一个创建对象的类，由这个类来封装实例化对象的行为

![image-20210527221656439](src/main/resources/image/typora-user-images/image-20210527221656439.png)

##### 工厂方法模式

###### 概念

工厂方法模式：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。

![image-20210527222023810](src/main/resources/image/typora-user-images/image-20210527222023810.png)



##### 抽象工厂模式

###### 概念

定义了一个interface用于创建相关或者有依赖关系的对象簇，而无需指明具体的类；抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。将工厂抽象成两层，抽象工厂和具体实现的工厂子类。

![image-20210527222438393](src/main/resources/image/typora-user-images/image-20210527222438393.png)



##### 原型模式

###### 概念

1. 原型模式（Prototype）是指：用原型实例指定创建对象的种类，并通过拷贝这些原型，创建新的对象
2. 原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需指定如何创建的细节
3. 工作原理：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即对象.clone()

![image-20210528000712292](src/main/resources/image/typora-user-images/image-20210528000712292.png)

###### 浅拷贝

1. 对于数据类型是基本类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。
2. 对于数据类型是引用数据类型的成员变量，那么浅拷贝会进行引用传递

###### 深拷贝

1. 复制对象的所有基本数据类型的成员变量值

2. 为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象

3. 深拷贝的实现方式：

   1. 重写clone方法
   2. 通过对象序列号实现

   

2. 状态模式
3. 解释器模式
4. 建造者模式
6. 单例模式
7. 适配器模式
8. 工厂模式
9. 